<h3 align="center">Описание hypertree_width_approximation внутри New_CHR</h3>
Поскольку мы используем итеративный метод, основанный на простой эвристике, алгоритм выполняется несколько раз (в нашем примере — 100 раз, но это число можно изменить). Повторное выполнение с разными начальными условиями позволяет избежать застревания в локальных минимумах.

На каждой итерации мы случайным образом упорядочиваем узлы гиперграфа с помощью функции random.shuffle. Это очень важно, так как результат зависит от порядка обработки узлов. Переменная width инициализируется равным 0. Она будет хранить ширину для текущей перестановки.

Проходя по каждому узлу, мы выполняем следующие шаги:
1. Находим всех соседей данного узла. Соседями считаются все узлы, которые встречаются в одном и том же ребре с текущим узлом.
2. Вычисляем количество соседей (len(node_neighbors) – 1). Вычитаем единицу, так как сам узел не считается соседом в контексте вычисления ширины.
3. Обновляем ширину, взяв максимум из текущего значения width и количества соседей текущего узла.

После завершения прохода по всем узлам в текущей перестановке, best_width обновляется, если текущая ширина меньше лучшей. В конце мы возвращаем best_width как окончательный результат.
