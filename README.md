Описание hypertree_width_approximation внутри New_CHR
Поскольку мы используем итеративный подход(простая эвристика) алгоритм выполняется несколько раз (в примере 100 раз, но это число можно изменить). Многократное выполнение с разными начальными условиями помогает избежать застревания в локальных минимумах.

В каждой итерации создается случайная перестановка (упорядочивание) узлов гиперграфа с помощью random.shuffle. Это важно, так как результат зависит от порядка обработки узлов. width инициализируется 0. Это переменная, которая будет хранить ширину для текущей перестановки.

В результате прохода по каждому узлу мы делаем:
1) Находим всех соседей этого узла. Соседи — это все узлы, которые встречаются в одном и том же ребре с текущим узлом.
2) Вычисляем количество соседей (len(node_neighbors)). Вычитается 1, потому что сам узел не считается соседом в контексте вычисления ширины.
3) width обновляется как максимум из текущего значения width и количества соседей текущего узла.

После прохода по всем узлам в текущей перестановке, best_width обновляется, если текущая width меньше best_width. И в конце возражаем best_width.
